#!/usr/bin/env python3
"""
Push-to-talk voice input with global hotkey
Hold INSERT to record, release to transcribe and auto-type
"""
import sounddevice as sd
import numpy as np
import whisper
import tempfile
import subprocess
import sys
import shutil
import threading
import queue
import argparse

SAMPLE_RATE = 16000
audio_queue = queue.Queue()
recording = False
audio_data = []
model = None
model_loaded = threading.Event()

def check_dependencies():
    """Check that required system dependencies are available"""
    if not shutil.which("xdotool"):
        print("‚ùå Error: xdotool is not installed", file=sys.stderr)
        print("   Install with: sudo apt install xdotool", file=sys.stderr)
        sys.exit(1)

    # Check for audio input device
    try:
        devices = sd.query_devices()
        input_devices = [d for d in devices if d['max_input_channels'] > 0]
        if not input_devices:
            print("‚ùå Error: No microphone found", file=sys.stderr)
            sys.exit(1)
    except Exception as e:
        print(f"‚ùå Error checking audio devices: {e}", file=sys.stderr)
        sys.exit(1)

def load_model(model_name):
    global model
    print(f"Loading Whisper model '{model_name}'...", file=sys.stderr)
    try:
        model = whisper.load_model(model_name)
        model_loaded.set()
        print("‚úÖ Ready! Hold INSERT to speak", file=sys.stderr)
    except Exception as e:
        print(f"‚ùå Error loading Whisper model: {e}", file=sys.stderr)
        sys.exit(1)

def audio_callback(indata, frames, time, status):
    if recording:
        audio_queue.put(indata.copy())

def start_recording():
    global recording, audio_data
    if not recording:
        recording = True
        audio_data = []
        # Clear any stale audio from queue
        while not audio_queue.empty():
            try:
                audio_queue.get_nowait()
            except:
                break
        print("üî¥ Recording...", file=sys.stderr)

def stop_recording():
    global recording, audio_data
    if recording:
        recording = False

        # Wait for model if not loaded yet
        if not model_loaded.is_set():
            print("‚è≥ Waiting for model to load...", file=sys.stderr)
            model_loaded.wait()

        # Collect audio from queue
        while not audio_queue.empty():
            try:
                audio_data.append(audio_queue.get_nowait())
            except:
                break

        if audio_data and len(audio_data) > 0:
            print("‚è≥ Transcribing...", file=sys.stderr)
            audio = np.concatenate(audio_data, axis=0)

            # Only process if we have enough audio (at least 0.3 seconds)
            if len(audio) > SAMPLE_RATE * 0.3:
                # Save and transcribe
                try:
                    with tempfile.NamedTemporaryFile(suffix=".wav", delete=True) as f:
                        import scipy.io.wavfile as wav
                        wav.write(f.name, SAMPLE_RATE, (audio * 32767).astype(np.int16))
                        result = model.transcribe(f.name)

                    text = result["text"].strip()
                    if text:
                        print(f"üìù {text}", file=sys.stderr)
                        # Type the text using xdotool
                        subprocess.run(
                            ["xdotool", "type", "--clearmodifiers", "--delay", "0", "--", text],
                            check=True
                        )
                except subprocess.CalledProcessError as e:
                    print(f"‚ö†Ô∏è Failed to type text: {e}", file=sys.stderr)
                except Exception as e:
                    print(f"‚ö†Ô∏è Transcription error: {e}", file=sys.stderr)
            else:
                print("‚ö†Ô∏è Recording too short", file=sys.stderr)
        else:
            print("‚ö†Ô∏è No audio captured", file=sys.stderr)

def main():
    parser = argparse.ArgumentParser(description="Push-to-talk voice input")
    parser.add_argument(
        "--model", "-m",
        choices=["tiny", "base", "small", "medium", "large"],
        default="base",
        help="Whisper model to use (default: base)"
    )
    args = parser.parse_args()

    # Import here to avoid issues if pynput isn't installed
    try:
        from pynput import keyboard
    except ImportError:
        print("‚ùå Error: pynput is not installed", file=sys.stderr)
        print("   Install with: pip install pynput", file=sys.stderr)
        sys.exit(1)

    # Check dependencies before starting
    check_dependencies()

    def on_press(key):
        if key == keyboard.Key.insert:
            start_recording()

    def on_release(key):
        if key == keyboard.Key.insert:
            stop_recording()
        elif key == keyboard.Key.esc:
            print("üëã Exiting...", file=sys.stderr)
            return False  # Stop listener

    # Load model in background
    threading.Thread(target=load_model, args=(args.model,), daemon=True).start()

    # Start audio stream
    try:
        stream = sd.InputStream(callback=audio_callback, channels=1, samplerate=SAMPLE_RATE)
        stream.start()
    except Exception as e:
        print(f"‚ùå Error starting audio stream: {e}", file=sys.stderr)
        sys.exit(1)

    # Start keyboard listener
    print("Starting voice hotkey... (ESC to quit)", file=sys.stderr)
    with keyboard.Listener(on_press=on_press, on_release=on_release) as listener:
        listener.join()

    stream.stop()

if __name__ == "__main__":
    main()
